\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\sloppy
\makeindex

\onefile
\htmloutput{html}				% Output directory
\htmlmainfile{index}				% Main document file
\bodycolor{white}				% Page colour

\renewcommand{\runningtitle}{SWI-Prolog Unit Tests}

\begin{document}

\title{SWI-Prolog Unit Tests}
\author{Jan Wielemaker \\
	HCS, \\
	University of Amsterdam \\
	The Netherlands \\
	E-mail: \email{wielemak@science.uva.nl}}

\maketitle

\begin{abstract}
This document describes the SWI-Prolog unit-test framework.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{Introduction}
\label{sec:intro}

There is really no excuse not to write tests!

Automatic testing of software during development is probably the most
important Quality Assurance measure. Tests can validate the final
system, which is nice or your users.  Most (Prolog) developers
however forget it is not just a burden during development.

\begin{itemize}
    \item Tests document how the code is supposed to be used.
    \item Tests can validate claims you make on the Prolog
          implementation.  Writing a test makes the claim
	  explicit.
    \item Tests avoid big applications saying `No' after
          modifications.  This saves time during development,
	  and it saves \emph{a lot} of time if you must return
	  to the application a few years later or you must
	  modify and debug someone else's application.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Unit Test box}
\label{sec:unitbox}

Tests are written in pure Prolog and enclosed within the directives
begin_tests/1 and end_tests/1. They can be embedded inside a normal
source module, or be placed in a seperate test-file that loads the files
that to be tested. Code inside a test box is normal Prolog code. The
entry points are defined by rules using the head \term{test}{Name} or
\term{test}{Name, Options}, where \arg{Name} is a ground term and
\arg{Options} is a list describing additional properties of the test.
Here is a very simple example:

\begin{code}
:- begin_tests(lists).
:- use_module(library(lists)).

test(reverse) :-
	reverse([a,b], [b,a]).

:- end_tests(lists).
\end{code}

The second argument of the test-head defines additional processing
options.  Defined options are:

\begin{description}
    \termitem{blocked}{+Reason:atom}
The test is currently disabled.   Tests are flagged as blocked if they
are known not to work but this accepted as something that must be fixed
in the future.

    \termitem{condition}{:Goal}
Test pre-conditions for running the test.  If the condition fails
the test is skipped.  The condition can be used as an alternative
to the \const{setup} option.  The only difference is that failure
of a condition skips the test and is considered an error when using
the \const{setup} option.

    \termitem{setup}{:Goal}
\arg{Goal} is run before the test-body.  Typically used together with
the \const{cleanup} option to create and destroy the required execution
environment.

    \termitem{cleanup}{:Goal}
\arg{Goal} is always called after completion of the test-body,
regardless of whether it fails, succeeds or throws an exception.  This
option or call_cleanup/2 must be used by tests that require side-effects
that must be reverted after the test completes.  \arg{Goal} may share
variables with the test body.

\begin{code}
create_file(Tmp) :-
	tmp_file(plunit, Tmp),
	open(Tmp, write, Out),
	write(Out, 'hello(World).\n'),
	close(Out).

test(read, [ setup(create_file(Tmp)),
	     cleanup(delete_file(Tmp))
	   ]) :-
	read_file_to_terms(Tmp, Terms, []),
	Term =@= hello(_).
\end{code}

    \termitem{true}{Vars Cmp Values}
Body must succeed deterministically. Bindings are compared to Values.
\arg{Cmp} is typically one of =/2, ==/2, =:=/2 or =@=/2, but any test
can be used. This is the same as inserting the test at the end of the
conjunction, but it allows the test engine to distinguish between
failure of copy_term/2 and producing the wrong value. Multiple variables
must be combined in an arbitrary compound term.  E.g.\
\verb$A1-A2 == v1-v2$

\begin{code}
test(copy, [ true(Copy =@= hello(X,X))
	   ]) :-
	copy_term(hello(Y,Y), Copy).
\end{code}

    \termitem{fail}{}
Body must fail.

    \termitem{throws}{Error}
Body must throw \arg{Error}. The error is verified using =@=/2.
If \arg{Error} is of the format \term{error}{Formal, Context},
\arg{Formal} is verified using =@=/2, but \arg{Context} simply
using unification (=/2).

    \termitem{all}{Vars Cmp List}
Similar to \term{true}{Vars Cmp Values}, but used for non-deterministic
predicates.  Each element is compared using \arg{Cmp}.  Order matters.

    \termitem{set}{Vars Cmp List}
Similar to \term{true}{Vars Cmp Values}, but used for non-deterministic
predicates.  Each element is compared using \arg{Cmp}.  Order and
duplicates with respect to \arg{Cmp} are ignored.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Writing the test body}
\label{sec:testbody}

The test-body is ordinary Prolog code. Without any options, the body
must be designed to succeed \emph{deterministically}. Any other result
is considered a failure. One of the options \const{fail}, \const{true},
\const{throws}, \const{all} or \const{set} can be used to specify a
different expected result. See \secref{unitbox} for details.  In this
section we illustrate typical test-scenarios by testing SWI-Prolog
built-in and library predicates.

\subsubsection{Testing deterministic predicates}
\label{sec:testdet}

Deterministic predicates are predicates that must succeed exactly once
and, for well behaved predicates, leave no choicepoints. Typically they
have zero or more input- and zero or more output arguments. The test
goal supplies proper values for the input arguments and verifies the
output arguments. Verification can use test-options or be explicit in
the body.  The tests in the example below are equivalent.

\begin{code}
test(add) :-
	A is 1 + 2,
	A =:= 3.

test(add, [true(A =:= 3)]) :-
	A is 1 + 2.
\end{code}

The test engine verifies that the test-body does not leave a
choicepoint.  We illustrate that using the test below:

\begin{code}
test(member) :-
	member(b, [a,b,c]).
\end{code}

Although this test succeeds, member/2 leaves a choicepoint which is
reported by the test subsystem.  To make the test silent, use the
code below.

\begin{code}
test(member) :-
	member(b, [a,b,c]), !.
\end{code}

\subsubsection{Testing semi-deterministic predicates}
\label{sec:testsemidet}

Semi-deterministic predicates are predicates that either fail or succeed
exactly once and, for well behaved predicates, leave no choicepoints.
Testing such predicates the the same as testing deterministic
predicates.  Negative tests must be specified using the option
\const{fail} or by negating the boty using \verb$\+/1$.

\begin{code}
test(is_set) :-
	\+ is_set([a,a]).

test(is_set, [fail]) :-
	is_set([a,a]).
\end{code}


\subsubsection{Testing non-deterministic predicates}
\label{sec:testnondet}

Non-deterministic predicates succeed zero or more times.  Their results
are tested either using findall/3 or setof/3 followed by a value-check
or using the \const{all} or \const{set} options.  The following are
equivalent tests:

\begin{code}
test(member) :-
	findall(X, member(X, [a,b,c]), Xs),
	Xs == [a,b,c].

test(member, all(X == [a,b,c]) :-
	member(X, [a,b,c]).
\end{code}

\subsubsection{Testing error conditions}
\label{sec:testnondet}

Error-conditions are tested using the option \term{throws}{Error} or
by wrapping the test in a catch/3.  The following tests are equivalent:

\begin{code}
test(div0) :-
     catch(A is 1/0, error(E, _), true),
     E =@= evaluation_error(zero_divisor).

test(div0, [throws(error(evaluation_error(zero_divisor), _))]) :-
     A is 1/0.
\end{code}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Running the test-suite}
\label{sec:running}

At any time, the tests can be executed by loading the program and
running run_tests/0 or run_tests(+Unit).  

\begin{description}
    \predicate{run_tests}{0}{}
Run all test-units.

    \predicate{run_tests}{1}{+Spec}
Run only the specified tests.  \arg{Spec} can be a list to run multiple
tests.  A single specification is either the name of a test unit or
a term <Unit>:<Tests>, running only the specified test.  <Tests> is
either the name of a test or a list of names. Running particular
tests is particulary useful for tracing a test:%
\footnote{Unfortunately the body of the test is called through
meta-calling, so it cannot be traced. The called user-code can be traced
normally though.}

\begin{code}
?- gtrace, run_tests(lists:member).
\end{code}
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tests and production systems}
\label{sec:state}

Most applications do not want the test-suite to end up in the
final application.  There are several ways to achieve this.  One
is to places all tests in seperate files and not to load the tests
when creating the production environment.  Alternatively, use the
directive below before loading the application.

\begin{code}
:- set_test_options([load(never)]).
\end{code}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Controlling the test suite}
\label{sec:options}

\begin{description}
    \predicate{set_test_options}{1}{+Options}
Defined options are:

\begin{description}
    \termitem{load}{+Load}
Determines whether or not tests are loaded. When \const{never},
everything between begin_tests/1 and end_tests/1 is simply ignored.
When \const{always}, tests are always loaded.  Finally, when using
the default value \const{normal}, tests are loaded if the code is
not compiled with optimisation turned on.

    \termitem{run}{+Run}
Specifies when tests are ran.  Using \const{manual}, tests can 
only be run using run_tests/0 or run_tests/1.  Using \const{make},
tests will be run for reloaded files, but not for files loaded the
first time.
\end{description}
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Portability of the test-suite}
\label{sec:porting}

One of the reasons to have tests is to simplify migrating code between
Prolog implementations. Unfortunately creating a portable test-suite
implies a poor integration into the development environment. Luckily,
the specification of the test-system proposed here can be ported quite
easily to most Prolog systems sufficiently compatible to SWI-Prolog to
consider porting your application. Most important is to have support for
term_expansion/2.

In the current system, test units are compiled into sub-modules of the
module in which they appear.  Few Prolog systems allow for sub-modules
and therefore ports may have to fall-back to inject the code in the
surrounding module.  This implies that support predicates used inside
the test unit should not conflict with predicates of the module being
tested.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Motivation of choices}
\label{sec:motivation}

\subsection*{Easy to understand and flexible}

There are two approaches for testing. In one extreme the tests are
written using declarations dealing with setup, cleanup, running and
testing the result. In the other extreme a test it simply a Prolog goal
that is supposed to succeed. We have choosen to allow for any mixture of
these approaches. Written down as test/1 we opt for the simple
succeeding goal approach. Using options to the test the user can choose
for a more declarative specification.  The user can mix both approaches.

The body of the test appears at the position of a clause-body. This
simplifies identification of the test body and ensures proper layout and
colouring support from the editor without the need for explicit support
of the unit test module. Only clauses of test/1 and test/2 may be marked
as non-called in environments that perform cross-referencing.

%\subsection*{Well integrated}

\printindex

\end{document}

