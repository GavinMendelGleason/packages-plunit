\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\sloppy
\makeindex

\onefile
\htmloutput{html}				% Output directory
\htmlmainfile{index}				% Main document file
\bodycolor{white}				% Page colour

\renewcommand{\runningtitle}{SWI-Prolog Unit Tests}

\begin{document}

\title{SWI-Prolog Unit Tests}
\author{Jan Wielemaker \\
	HCS, \\
	University of Amsterdam \\
	The Netherlands \\
	E-mail: \email{wielemak@science.uva.nl}}

\maketitle

\begin{abstract}
This document describes the SWI-Prolog unit-test framework.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Unit Test box}
\label{sec:unitbox}

Tests are written in pure Prolog and enclosed within the directives
begin_tests/1 and end_tests/1. They can be embedded inside a normal
source module, or be placed in a seperate test-file that loads the files
that must be tested. Code inside a test box is normal Prolog code. The
entry points are defined by rules using the head \term{test}{Name} or
\term{test}{Name, Options}, where \arg{Name} is a ground term and
\arg{Options} is a list describing additional properties of the test.
Here is a very simple example:

\begin{code}
:- begin_tests(lists).
:- use_module(library(lists)).

test(member) :-
	member(a, [a]).

:- end_tests(lists).
\end{code}

The second argument of the test-head defines additional processing
options.  Defined options are:

\begin{description}
    \termitem{blocked}{+Reason:atom}
The test is currently disabled.   Tests are flagged as blocked if they
are known not to work but this accepted as something that must be fixed
in the future.

    \termitem{setup}{:Goal}
\arg{Goal} is run before the test-body.  Typically used together with
the \const{cleanup} option to create and destroy the required execution
environment.

    \termitem{cleanup}{:Goal}
\arg{Goal} is always called after completion of the test-body,
regardless of whether it fails, succeeds or throws an exception.  This
option or call_cleanup/2 must be used by tests that require side-effects
that must be reverted after the test completes.  \arg{Goal} may share
variables with the test body.

\begin{code}
create_file(Tmp) :-
	tmp_file(Tmp),
	open(Tmp, write, Out),
	write(Out, 'hello(World).\n'),
	close(Out).

test(read, [ setup(create_file(Tmp)),
	     cleanup(delete_file(Tmp))
	   ]) :-
	read_file_to_terms(Tmp, Terms, []),
	Term =@= hello(_).
\end{code}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Writing the test body}
\label{sec:testbody}

The test-body is ordinary Prolog code that must be designed to succeed
\emph{deterministically}. Any other result is considered a failure. In
this section we illustrate typical test-scenarios by testing SWI-Prolog
built-in and library predicates.

\subsubsection{Testing deterministic predicates}
\label{sec:testdet}

Deterministic predicates are predicates that must succeed exactly once
and, for well behaved predicates, leave no choicepoints. Typically they
have zero or more input- and zero or more output arguments. The test
goal supplies proper values for the input arguments and verifies the
output arguments.

\begin{code}
test(add) :-
	A is 1 + 2,
	A =:= 3.
\end{code}




\subsubsection{Testing semi-deterministic predicates}
\label{sec:testsemidet}


\subsubsection{Testing non-deterministic predicates}
\label{sec:testnondet}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Motivation of choices}
\label{sec:motivation}


\printindex

\end{document}

